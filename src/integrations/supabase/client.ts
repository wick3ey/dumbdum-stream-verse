
// This file is automatically generated. Do not edit it directly.
import type { Database } from './types';

// Define minimal types we need for our implementation
export type Session = {
  user: User | null;
  access_token: string | null;
};

export type User = {
  id: string;
  email?: string;
  user_metadata: Record<string, any>;
};

// Create a mock client with improved authentication
class SupabaseClient {
  private users: Map<string, { password: string, user: User }> = new Map();
  private user: User | null = null;
  private session: Session | null = null;
  private listeners: Array<(event: string, session: Session | null) => void> = [];

  constructor() {
    // Try to load session from localStorage if available
    try {
      const savedSession = localStorage.getItem('supabase.auth.token');
      if (savedSession) {
        const parsed = JSON.parse(savedSession);
        this.session = parsed;
        this.user = parsed.user;
      }
      
      // Load stored users from localStorage
      const savedUsers = localStorage.getItem('supabase.auth.users');
      if (savedUsers) {
        const parsed = JSON.parse(savedUsers);
        this.users = new Map(parsed);
      }
    } catch (error) {
      console.error('Error loading data:', error);
    }
  }

  // Helper method to save users to localStorage
  private saveUsers() {
    try {
      localStorage.setItem('supabase.auth.users', 
        JSON.stringify(Array.from(this.users.entries())));
    } catch (error) {
      console.error('Error saving users:', error);
    }
  }

  get auth() {
    return {
      getSession: async () => {
        return { data: { session: this.session } };
      },
      
      onAuthStateChange: (callback: (event: string, session: Session | null) => void) => {
        this.listeners.push(callback);
        return { 
          data: { 
            subscription: { 
              unsubscribe: () => {
                this.listeners = this.listeners.filter(listener => listener !== callback);
              } 
            } 
          } 
        };
      },
      
      signUp: async ({ email, password, options }: { email: string; password: string; options?: { data?: any } }) => {
        // Check if user already exists
        const username = options?.data?.username;
        if (!username || !password || password.length < 6) {
          return { 
            data: { user: null }, 
            error: { message: "Invalid username or password (password must be at least 6 characters)" } 
          };
        }
        
        if (this.users.has(username)) {
          return { 
            data: { user: null }, 
            error: { message: "User already exists" } 
          };
        }
        
        // Create new user
        const newUser = {
          id: `user-${Date.now()}`,
          email,
          user_metadata: options?.data || {}
        };
        
        // Store user with hashed password (in a real app, you'd use bcrypt)
        this.users.set(username, { 
          password, 
          user: newUser 
        });
        
        this.saveUsers();
        
        return { data: { user: newUser }, error: null };
      },
      
      signInWithPassword: async ({ email, password }: { email: string; password: string }) => {
        // Extract username from email (username@example.com format)
        const username = email.split('@')[0];
        
        // Check if user exists and password matches
        const userRecord = this.users.get(username);
        
        if (!userRecord || userRecord.password !== password) {
          return { 
            data: { user: null, session: null }, 
            error: { message: "Invalid login credentials" } 
          };
        }
        
        // Successful login
        this.user = userRecord.user;
        this.session = { 
          user: this.user, 
          access_token: `mock-token-${Date.now()}` 
        };
        
        // Save to localStorage to persist across page reloads
        localStorage.setItem('supabase.auth.token', JSON.stringify(this.session));
        
        // Notify listeners
        this.listeners.forEach(listener => listener('SIGNED_IN', this.session));
        
        return { data: { user: this.user, session: this.session }, error: null };
      },
      
      signOut: async () => {
        this.user = null;
        this.session = null;
        localStorage.removeItem('supabase.auth.token');
        
        // Notify listeners
        this.listeners.forEach(listener => listener('SIGNED_OUT', null));
        
        return { error: null };
      }
    };
  }

  // Add minimal implementation for other needed methods
  from(table: string) {
    // Return a chainable object with basic query methods
    return {
      select: (columns: string) => ({
        eq: (field: string, value: any) => ({
          single: async () => ({ data: null, error: null }),
          maybeSingle: async () => ({ data: null, error: null }),
          execute: async () => ({ data: [], error: null })
        }),
        order: (field: string, { ascending }: { ascending: boolean }) => ({
          limit: (n: number) => ({
            execute: async () => ({ data: [], error: null })
          }),
          execute: async () => ({ data: [], error: null })
        }),
        execute: async () => ({ data: [], error: null })
      }),
      insert: (data: any) => ({
        select: () => ({
          execute: async () => ({ data: [data], error: null })
        })
      }),
      update: (data: any) => ({
        eq: (field: string, value: any) => ({
          select: () => ({
            execute: async () => ({ data: [data], error: null })
          })
        })
      })
    };
  }

  // Add basic implementation of rpc for functions
  rpc(functionName: string, params: any) {
    return new Promise((resolve) => {
      resolve({ data: null, error: null });
    });
  }

  channel(channelName: string) {
    return {
      on: (event: string, filter: any, callback: (payload: any) => void) => {
        return {
          subscribe: () => {
            return {};
          }
        };
      }
    };
  }

  removeChannel(channel: any) {
    // Mock implementation, no actual cleanup needed
  }
}

// Export mock client
export const supabase = new SupabaseClient() as any;

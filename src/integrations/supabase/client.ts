
// This file is automatically generated. Do not edit it directly.
import type { Database } from './types';

// Define minimal types we need for our implementation
export type Session = {
  user: User | null;
  access_token: string | null;
};

export type User = {
  id: string;
  email?: string;
  user_metadata: Record<string, any>;
};

// Create a mock client with improved authentication
class SupabaseClient {
  private users: Map<string, { password: string, user: User, failedAttempts: number, lockedUntil: number | null }> = new Map();
  private user: User | null = null;
  private session: Session | null = null;
  private listeners: Array<(event: string, session: Session | null) => void> = [];
  private ipAttempts: Map<string, {count: number, lastAttempt: number}> = new Map();
  private MAX_ATTEMPTS = 5;
  private LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes in milliseconds
  private ATTEMPT_RESET_TIME = 10 * 60 * 1000; // 10 minutes in milliseconds

  constructor() {
    // Try to load session from localStorage if available
    try {
      const savedSession = localStorage.getItem('supabase.auth.token');
      if (savedSession) {
        const parsed = JSON.parse(savedSession);
        this.session = parsed;
        this.user = parsed.user;
      }
      
      // Load stored users from localStorage
      const savedUsers = localStorage.getItem('supabase.auth.users');
      if (savedUsers) {
        const parsed = JSON.parse(savedUsers);
        this.users = new Map(parsed.map((entry: [string, any]) => {
          // Add security fields if they don't exist
          if (!entry[1].failedAttempts) {
            entry[1].failedAttempts = 0;
          }
          if (!entry[1].lockedUntil) {
            entry[1].lockedUntil = null;
          }
          return entry;
        }));
      }
    } catch (error) {
      console.error('Error loading data:', error);
    }
  }

  // Helper method to save users to localStorage
  private saveUsers() {
    try {
      localStorage.setItem('supabase.auth.users', 
        JSON.stringify(Array.from(this.users.entries())));
    } catch (error) {
      console.error('Error saving users:', error);
    }
  }

  // Simulate IP-based rate limiting
  private checkRateLimit(ipAddress = 'default-ip') {
    const now = Date.now();
    const ipRecord = this.ipAttempts.get(ipAddress) || { count: 0, lastAttempt: 0 };
    
    // Reset count if it's been a while since last attempt
    if (now - ipRecord.lastAttempt > this.ATTEMPT_RESET_TIME) {
      ipRecord.count = 0;
    }
    
    // Update attempt record
    ipRecord.count += 1;
    ipRecord.lastAttempt = now;
    this.ipAttempts.set(ipAddress, ipRecord);
    
    // Check if rate limited
    if (ipRecord.count > this.MAX_ATTEMPTS * 2) { // IP limit is higher than account specific limit
      return { allowed: false, message: "Too many login attempts. Please try again later." };
    }
    
    return { allowed: true };
  }

  get auth() {
    return {
      getSession: async () => {
        return { data: { session: this.session } };
      },
      
      onAuthStateChange: (callback: (event: string, session: Session | null) => void) => {
        this.listeners.push(callback);
        return { 
          data: { 
            subscription: { 
              unsubscribe: () => {
                this.listeners = this.listeners.filter(listener => listener !== callback);
              } 
            } 
          } 
        };
      },
      
      signUp: async ({ email, password, options }: { email: string; password: string; options?: { data?: any } }) => {
        // Check if user already exists
        const username = options?.data?.username;
        
        // Validate inputs
        if (!username || username.length < 3) {
          return { 
            data: { user: null }, 
            error: { message: "Username must be at least 3 characters" } 
          };
        }
        
        if (!password || password.length < 6) {
          return { 
            data: { user: null }, 
            error: { message: "Password must be at least 6 characters" } 
          };
        }
        
        // Check for suspicious patterns (basic detection)
        if (/admin|root|superuser/i.test(username) && username.length < 8) {
          return {
            data: { user: null },
            error: { message: "Invalid username. Please choose another." }
          };
        }
        
        if (this.users.has(username)) {
          return { 
            data: { user: null }, 
            error: { message: "User already exists" } 
          };
        }
        
        // Create new user
        const newUser = {
          id: `user-${Date.now()}`,
          email,
          user_metadata: options?.data || {}
        };
        
        // Store user with hashed password (in a real app, you'd use bcrypt)
        this.users.set(username, { 
          password, 
          user: newUser,
          failedAttempts: 0,
          lockedUntil: null
        });
        
        this.saveUsers();
        
        return { data: { user: newUser }, error: null };
      },
      
      signInWithPassword: async ({ email, password }: { email: string; password: string }) => {
        // Extract username from email (username@example.com format)
        const username = email.split('@')[0];
        
        // Rate limiting check (simulated IP-based)
        const rateLimitCheck = this.checkRateLimit();
        if (!rateLimitCheck.allowed) {
          return {
            data: { user: null, session: null },
            error: { message: rateLimitCheck.message }
          };
        }
        
        // Check if user exists
        const userRecord = this.users.get(username);
        
        if (!userRecord) {
          // Don't reveal if user exists or not to prevent enumeration attacks
          return { 
            data: { user: null, session: null }, 
            error: { message: "Invalid login credentials" } 
          };
        }
        
        // Check if account is locked
        if (userRecord.lockedUntil && Date.now() < userRecord.lockedUntil) {
          const minutesLeft = Math.ceil((userRecord.lockedUntil - Date.now()) / (60 * 1000));
          return {
            data: { user: null, session: null },
            error: { message: `Account is temporarily locked. Try again in ${minutesLeft} minutes.` }
          };
        }
        
        // Check password
        if (userRecord.password !== password) {
          // Increment failed attempts
          userRecord.failedAttempts += 1;
          
          // Lock account if too many failed attempts
          if (userRecord.failedAttempts >= this.MAX_ATTEMPTS) {
            userRecord.lockedUntil = Date.now() + this.LOCKOUT_DURATION;
            this.saveUsers();
            return {
              data: { user: null, session: null },
              error: { message: "Account locked due to too many failed attempts. Try again later." }
            };
          }
          
          this.saveUsers();
          return { 
            data: { user: null, session: null }, 
            error: { message: "Invalid login credentials" } 
          };
        }
        
        // Successful login - reset failed attempts
        userRecord.failedAttempts = 0;
        userRecord.lockedUntil = null;
        this.saveUsers();
        
        // Create session
        this.user = userRecord.user;
        this.session = { 
          user: this.user, 
          access_token: `mock-token-${Date.now()}` 
        };
        
        // Save to localStorage to persist across page reloads
        localStorage.setItem('supabase.auth.token', JSON.stringify(this.session));
        
        // Notify listeners
        this.listeners.forEach(listener => listener('SIGNED_IN', this.session));
        
        return { data: { user: this.user, session: this.session }, error: null };
      },
      
      signOut: async () => {
        this.user = null;
        this.session = null;
        localStorage.removeItem('supabase.auth.token');
        
        // Notify listeners
        this.listeners.forEach(listener => listener('SIGNED_OUT', null));
        
        return { error: null };
      }
    };
  }

  // Fixa from-metoden för att hantera multiple .eq()-anrop
  from(table: string) {
    let filters: { field: string; value: any }[] = [];
    
    return {
      select: (columns: string) => {
        return {
          eq: (field: string, value: any) => {
            filters.push({ field, value });
            
            return {
              eq: (field: string, value: any) => {
                filters.push({ field, value });
                
                return {
                  eq: (field: string, value: any) => {
                    filters.push({ field, value });
                    
                    return {
                      order: (field: string, { ascending }: { ascending: boolean }) => {
                        return {
                          maybeSingle: async () => {
                            // Returnera en standard mock-respons för nu
                            return { data: null, error: null };
                          },
                          limit: (n: number) => ({
                            execute: async () => ({ data: [], error: null })
                          }),
                          execute: async () => ({ data: [], error: null })
                        };
                      },
                      maybeSingle: async () => {
                        // Returnera en standard mock-respons för nu
                        return { data: null, error: null };
                      }
                    };
                  },
                  order: (field: string, { ascending }: { ascending: boolean }) => {
                    return {
                      maybeSingle: async () => {
                        // Returnera en standard mock-respons för nu
                        return { data: null, error: null };
                      },
                      limit: (n: number) => ({
                        execute: async () => ({ data: [], error: null })
                      }),
                      execute: async () => ({ data: [], error: null })
                    };
                  },
                  maybeSingle: async () => {
                    // Returnera en standard mock-respons för nu
                    return { data: null, error: null };
                  }
                };
              },
              order: (field: string, { ascending }: { ascending: boolean }) => {
                return {
                  maybeSingle: async () => {
                    // Returnera en standard mock-respons för nu
                    return { data: null, error: null };
                  },
                  limit: (n: number) => ({
                    execute: async () => ({ data: [], error: null })
                  }),
                  execute: async () => ({ data: [], error: null })
                };
              },
              single: async () => {
                // Returnera en standard mock-respons för nu
                return { data: null, error: null };
              },
              maybeSingle: async () => {
                // Returnera en standard mock-respons för nu
                return { data: null, error: null };
              }
            };
          },
          order: (field: string, { ascending }: { ascending: boolean }) => {
            return {
              limit: (n: number) => ({
                execute: async () => ({ data: [], error: null })
              }),
              execute: async () => ({ data: [], error: null })
            };
          },
          execute: async () => ({ data: [], error: null })
        };
      },
      insert: (data: any) => ({
        select: () => ({
          single: async () => ({ data: data[0] || null, error: null }),
          execute: async () => ({ data: data, error: null })
        }),
        execute: async () => ({ data, error: null })
      }),
      update: (data: any) => ({
        eq: (field: string, value: any) => ({
          select: () => ({
            single: async () => ({ data: data, error: null }),
            execute: async () => ({ data: [data], error: null })
          })
        })
      })
    };
  }

  // Add basic implementation of rpc for functions
  rpc(functionName: string, params: any) {
    return new Promise((resolve) => {
      resolve({ data: null, error: null });
    });
  }

  channel(channelName: string) {
    return {
      on: (event: string, filter: any, callback: (payload: any) => void) => {
        return {
          subscribe: () => {
            return {};
          }
        };
      }
    };
  }

  removeChannel(channel: any) {
    // Mock implementation, no actual cleanup needed
  }
}

// Export mock client
export const supabase = new SupabaseClient() as any;
